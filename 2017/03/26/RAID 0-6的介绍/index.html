<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>RAID 0-6的介绍 | Frank&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="RAID 0： RAID 0 并不是真正的RAID结构, 没有数据冗余。 RAID 0 连续地分割数据并并行地读/写于多个磁盘上。 因此具有很高的数据传输率。 但RAID 0在提高性能的同时,并没有提供数据可靠性,如果一个磁盘失效, 将影响整个数据.因此RAID 0 不可应用于需要数据高可用性的关键应用。
RAID 1： RAID 1通过数据镜像实现数据冗余, 在两对分离的磁盘上产生互为备份的数据">
<meta property="og:type" content="article">
<meta property="og:title" content="RAID 0-6的介绍">
<meta property="og:url" content="http://yoursite.com/2017/03/26/RAID 0-6的介绍/index.html">
<meta property="og:site_name" content="Frank's Blog">
<meta property="og:description" content="RAID 0： RAID 0 并不是真正的RAID结构, 没有数据冗余。 RAID 0 连续地分割数据并并行地读/写于多个磁盘上。 因此具有很高的数据传输率。 但RAID 0在提高性能的同时,并没有提供数据可靠性,如果一个磁盘失效, 将影响整个数据.因此RAID 0 不可应用于需要数据高可用性的关键应用。
RAID 1： RAID 1通过数据镜像实现数据冗余, 在两对分离的磁盘上产生互为备份的数据">
<meta property="og:updated_time" content="2017-03-26T14:11:38.779Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RAID 0-6的介绍">
<meta name="twitter:description" content="RAID 0： RAID 0 并不是真正的RAID结构, 没有数据冗余。 RAID 0 连续地分割数据并并行地读/写于多个磁盘上。 因此具有很高的数据传输率。 但RAID 0在提高性能的同时,并没有提供数据可靠性,如果一个磁盘失效, 将影响整个数据.因此RAID 0 不可应用于需要数据高可用性的关键应用。
RAID 1： RAID 1通过数据镜像实现数据冗余, 在两对分离的磁盘上产生互为备份的数据">
  
    <link rel="alternate" href="/atom.xml" title="Frank&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Frank&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-RAID 0-6的介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/26/RAID 0-6的介绍/" class="article-date">
  <time datetime="2017-03-26T11:43:01.234Z" itemprop="datePublished">2017-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      RAID 0-6的介绍
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>RAID 0： RAID 0 并不是真正的RAID结构, 没有数据冗余。 RAID 0 连续地分割数据并并行地读/写于多个磁盘上。 因此具有很高的数据传输率。 但RAID 0在提高性能的同时,并没有提供数据可靠性,如果一个磁盘失效, 将影响整个数据.因此RAID 0 不可应用于需要数据高可用性的关键应用。</p>
<p>RAID 1： RAID 1通过数据镜像实现数据冗余, 在两对分离的磁盘上产生互为备份的数据。 RAID 1可以提高读的性能,当原始数据繁忙时, 可直接从镜像拷贝中读取数据.RAID 1是磁盘阵列中费用最高的, 但提供了最高的数据可用率。当一个磁盘失效, 系统可以自动地交换到镜像磁盘上, 而不需要重组失效的数据。</p>
<p>RAID 2： 从概念上讲, RAID 2 同RAID 3类似, 两者都是将数据条块化分布于不同的硬盘上, 条块单位为位或字节。然而RAID 2 使用称为“加重平均纠错码”的编码技术来提供错误检查及恢复。这种编码技术需要多个磁盘存放检查及恢复信息, 使得RAID 2技术实施更复杂。 因此,在商业环境中很少使用。</p>
<p>RAID 3：不同于RAID 2, RAID 3使用单块磁盘存放奇偶校验信息。 如果一块磁盘失效, 奇偶盘及其他数据盘可以重新产生数据。 如果奇偶盘失效,则不影响数据使用。RAID 3对于大量的连续数据可提供很好的传输率, 但对于随机数据, 奇偶盘会成为写操作的瓶颈。</p>
<p>RAID 4： 同RAID 2, RAID 3一样, RAID 4, RAID 5也同样将数据条块化并分布于不同的磁盘上, 但条块单位为块或记录。 RAID 4使用一块磁盘作为奇偶校验盘, 每次写操作都需要访问奇偶盘, 成为写操作的瓶颈。 在商业应用中很少使用。</p>
<p>RAID 5：RAID 5没有单独指定的奇偶盘, 而是交叉地存取数据及奇偶校验信息于所有磁盘上。 在RAID5 上, 读/写指针可同时对阵列设备进行操作, 提供了更高的数据流量。 RAID 5更适合于小数据块,随机读写的数据.RAID 3与RAID 5相比, 重要的区别在于RAID 3每进行一次数据传输,需涉及到所有的阵列盘。而对于RAID 5来说, 大部分数据传输只对一块磁盘操作, 可进行并行操作。在RAID 5中有“写损失”, 即每一次写操作,将产生四个实际的读/写操作, 其中两次读旧的数据及奇偶信息, 两次写新的数据及奇偶信息。</p>
<p>RAID 6：RAID 6 与RAID 5相比,增加了第二个独立的奇偶校验信息块。 两个独立的奇偶系统使用不同的算法, 数据的可靠性非常高. 即使两块磁盘同时失效,也不会影响数据的使用。 但需要分配给奇偶校验信息更大的磁盘空间,相对于RAID 5有更大的“写损失”。RAID 6 的写性能非常差, 较差的性能和复杂的实施使得RAID 6很少使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/26/RAID 0-6的介绍/" data-id="cj0qrjwds0000r0ezyizgnors" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
    
  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/26/RAID 0-6的介绍/">RAID 0-6的介绍</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Frank<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>